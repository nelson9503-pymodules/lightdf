
# Column is the basic structure of lightdf, which controls and labels a list of values.
# It also restricts the data type of values and the data policy like allowance of none value.
class Column:

    # Every initializing Column object, users should set the data type and all the data policy.
    # Data types can be int, float, str, bool or None. Setting None means Column will not control data type of values.
    def __init__(self, data_type: type, is_unique: bool = False, is_not_none: bool = False):
        self.__setup_data_policy(is_unique, is_not_none)
        if not data_type in [int, float, str, bool, None]:
            raise AttributeError("Not recognized data type.")
        self.data_type = data_type
        # self.data maps id to value.
        # id is an integer and auto-generated by udpate function.
        # The Dataframe class synchronize Columns by using this id.
        self.data = {}
        # self.keys will be used when the column is unique column.
        # self.keys maps the value to id. (opposite to self.data)
        # This dictionary is used to check unique and get the id from value.
        self.keys = {}

    # update_value insert value for new id and update value for existed id.
    def update_value(self, id: int, value: any):
        value = self.__check_data_type(value)
        self.__check_not_none(value)
        self.__check_unique(id, value)
        self.data[id] = value
        self.__update_keys_map(id, value)

    # Dataframe should keeps different columns in the same size.
    # Dataframe can insert a initial value to do it.
    # Initial value is based on the data type of column.
    def insert_initial_value(self, id: int):
        if self.not_none == False:
            self.update_value(id, None)
        elif self.data_type == str:
            self.update_value(id, "")
        elif self.data_type == int:
            self.update_value(id, 0)
        elif self.data_type == float:
            self.update_value(id, 0.0)
        elif self.data_type == bool:
            self.update_value(id, False)

    # Get the value by id.
    def get_value(self, id: int) -> any:
        return self.data[id]

    # Drop the value by id.
    def drop_value(self, id: int):
        pop = self.data.pop(id, False)
        if not pop == False:  # drop from self.keys also
            self.keys.pop(pop, False)

    # Get the id by value.
    def get_id_by_value(self, value: any) -> int:
        """
        Only work for unique column.
        """
        if value in self.keys:
            return self.keys[value]
        return None

    # List out the values.
    # The data is stored in dictionary.
    # We need create a list and append values to it.
    def list_value(self) -> list:
        li = []
        ids = self.list_id()
        for id in ids:
            li.append(self.data[id])
        return li

    # Sort the values by using python list.sort()
    # The ids will be reset and start from 0.
    # The map of new id to old id will be returned so
    # dataframe can use it to synchronize others columns.
    def sort_value(self, ascending: bool = True) -> dict:
        values = self.list_value()
        values.sort(reverse=not ascending)  # ascending -> not reverse
        id_map = {}
        data = {}
        for i in range(len(values)):
            value = values[i]
            # We locate the value from old data dictionary.
            # We need the old id to build id_map for new id.
            for id in self.data:
                if self.data[id] == value:
                    # pop out to ensure this value cannot be found again
                    self.data.pop(id)
                    data[i] = value
                    id_map[id] = i
                    break
        self.data = data  # replace old data map
        self.__rebuild_keys_map()
        return id_map
    
    # Reset the ids by using id_map
    def sync_id_map(self, id_map: dict):
        data = {}
        for id in self.data:
            data[id_map[id]] = self.data[id]
        self.data = data
        self.__rebuild_keys_map()
        return id_map
    
    # Set the data type of column.
    def set_data_type(self, data_type: type):
        if not data_type in [int, float, str, bool, None]:
            raise AttributeError("Not recognized data type.")
        self.data_type = data_type
        # check all values if it is match to data type
        for id in self.data:
            self.update_value(id, self.data[id])
    
    # Set the column to be unqiue
    def set_unique(self, is_unique: bool):
        if is_unique == True:
            self.set_not_none(is_unique)
            # check if contains no duplicated values
            check = {}
            for id in self.data:
                if self.data[id] in check:
                    raise ValueError("Cannot set column to unique with duplicated values.")
            self.unique = is_unique
        else:
            self.unique = is_unique
            self.is_not_none = is_unique

    # Set the column to be not none
    def set_not_none(self, is_not_none: bool):
        """
        Set the column to be not none.
        """
        if is_not_none == True:
            # check if contains None values
            for id in self.data:
                if self.data[id] == None:
                    raise ValueError("Cannot set column to not none with None values.")
            self.not_none = is_not_none
        else:
            self.set_unique(is_not_none) # none column cannot be unique
            self.is_not_none = is_not_none

    # List out id.
    def list_id(self) -> list:
        ids = list(self.data.keys())
        ids.sort()
        return ids

    # Check the data type of input value.
    # If the input value type was not match to data type,
    # this method will try to convert it.
    # Error will raise if data type not match and failed to convert.
    def __check_data_type(self, value: any) -> any:
        if self.data_type == None:  # skip checking
            return value
        elif type(value) == self.data_type:  # match case
            return value
        elif self.data_type in [int, float, bool, str]:  # try to convert
            try:
                value = self.data_type(value)
            except:
                raise TypeError("Data type of input value is not match.")
        else:
            raise Exception("Invalid data type. This is a unexpected case.")

    # Setup the data policy.
    # The unique column cannot contains none values.
    def __setup_data_policy(self, is_unique: bool = False, is_not_none: bool = False):
        """
        Setup the data policy of column. 
        """
        if is_unique == True:
            self.unique = True
            self.not_none = True
        elif is_not_none == True:
            self.unique = False
            self.not_none = True
        else:
            self.unique = False
            self.not_none = False

    # This method check value for not-none data policy.
    def __check_not_none(self, value: any):
        if self.not_none == True and value == None:
            raise ValueError("Value cannot be None.")

    # This method check value for unique data policy.
    def __check_unique(self, id: int, value: any):
        if self.unique == True:
            if not value in self.keys:  # pass, no duplicated
                return
            # same value contains different id means duplicated.
            if not id == self.keys[value]:
                raise ValueError("Value cannot be duplicated.")

    # This method update the self.keys
    def __update_keys_map(self, id: int, value: any):
        if self.unique == True:
            if id in self.data:
                key_value = self.data[id]
                self.keys.pop(key_value, False)
            self.keys[value] = id
        else:
            # ensure this dict not consuming memories if it is no needed
            self.keys = {}
    
    # rebuild the self.keys for unique column
    def __rebuild_keys_map(self):
        if self.unique == True:
            self.keys = {}
            for id in self.data:
                self.keys[self.data[id]] = id


class Columns:

    def __init__(self, data_type: type, key_col: bool, unique_values: bool, none_values: bool):
        """
        data_type: int, float, str, bool, None (None -> disable data type checking.)

        key_col: True -> must be unique and not none. Plus, build a key dictionary for query.
        unique_values: True -> is unique and must not none.
        none_values: True -> not none but can not be unique.
        """
        if not data_type in [int, float, str, bool, None]:
            raise TypeError(
                "data_type can only be int, float, str, bool or None.")
        self.data_type = data_type
        if key_col == True:
            self.key_col = True
            self.unique = True
            self.none = False
        elif unique_values == True:
            self.key_col = False
            self.unique = True
            self.none = False
        elif none_values == False:
            self.key_col = False
            self.unique = False
            self.none = False
        else:
            self.key_col = False
            self.unique = False
            self.none = True
        self.key_dict = {}
        self.data_dict = {}

    def initialize_value(self, id: int):
        if self.none == False:
            if self.data_type in [str, None]:
                self.update_value(id, "")
            elif self.data_type == int:
                self.update_value(id, 0)
            elif self.data_type == float:
                self.update_value(id, 0.0)
            elif self.data_type == bool:
                self.update_value(id, False)
        else:
            self.update_value(id, None)

    def update_value(self, id: int, value: any):
        value = self.__check_data_type(value)
        if self.none == False and value == None:
            raise ValueError("Cannot input None value to a non-none column.")
        if self.unique == True:
            for check_id in self.data_dict:
                if check_id == id:
                    continue
                if self.data_dict[check_id] == value:
                    raise ValueError("Duplicated value in unique column.")
        if self.key_col == True and id in self.data_dict:
            key_value = self.data_dict[id]
            del self.key_dict[key_value]
        self.data_dict[id] = value
        if self.key_col == True:
            self.key_dict[value] = id

    def drop_value(self, id: int):
        if self.key_col == True:
            key_value = self.data_dict[id]
            del self.key_dict[key_value]
        del self.data_dict[id]

    def list_value(self) -> list:
        li = []
        ids = list(self.data_dict.keys())
        ids.sort()
        for id in ids:
            li.append(self.data_dict[id])
        return li

    def list_id(self) -> list:
        return list(self.data_dict.keys())

    def sort_value(self, ascending: bool = True) -> dict:
        values = self.list_value()
        if ascending == True:
            reverse = False
        else:
            reverse = True
        values.sort(reverse=reverse)
        id_map = {}
        data_dict = {}
        for i in range(len(values)):
            value = values[i]
            for id in self.data_dict:
                if self.data_dict[id] == value:
                    self.data_dict.pop(id, None)
                    data_dict[i] = value
                    id_map[id] = i
                    break
        self.data_dict = data_dict
        if self.key_col == True:
            self.key_dict = {}
            for id in self.data_dict:
                self.key_dict[self.data_dict[id]] = id
        return id_map

    def reset_id(self, id_map: dict):
        data_dict = {}
        for id in self.data_dict:
            data_dict[id_map[id]] = self.data_dict[id]
        self.data_dict = data_dict
        if self.key_col == True:
            self.key_dict = {}
            for id in self.data_dict:
                self.key_dict[self.data_dict[id]] = id

    def get_value(self, id: int) -> any:
        return self.data_dict[id]

    def get_key(self, key_value: any) -> any:
        if key_value in self.key_dict:
            return self.key_dict[key_value]
        return None

    def convert_value_type(self, data_type: type):
        self.data_type = data_type
        if data_type == None:
            return
        for id in self.data_dict:
            self.data_dict[id] = self.__check_data_type(
                self.data_type(self.data_dict[id]))
        if self.key_col == True:
            self.key_dict = {}
            for id in self.data_dict:
                self.key_dict[self.data_dict[id]] = id

    def set_none_value(self, none: bool):
        if none == False:
            for id in self.data_dict:
                if self.data_dict[id] == None:
                    raise ValueError("Set not none failed.")
            self.none = False
        else:
            self.none = True
            if self.unique == True:
                self.set_unique_column(False)

    def set_unique_column(self, unique: bool):
        if unique == True:
            self.set_none_value(False)
            check_dict = {}
            for id in self.data_dict:
                if self.data_dict[id] in check_dict:
                    raise ValueError("Set unique column failed.")
                check_dict[self.data_dict[id]] = None
            self.unique = True
        else:
            self.unique = False
            self.set_none_value(True)

    def set_key_col(self, key_col: bool):
        if key_col == True:
            self.set_unique_column(True)
            self.key_dict = {}
            for id in self.data_dict:
                self.key_dict[self.data_dict[id]] = id
            self.key_col = True
        else:
            self.key_col = False
            self.key_dict = {}

    def __check_data_type(self, value: any) -> any:
        if self.data_type == None:
            return value
        elif self.data_type in [int, float, bool, str]:
            try:
                if value == None:
                    return value
                value = self.data_type(value)
                return value
            except:
                raise TypeError("Value with invalid data type.")
        raise Exception(
            "Invalid data type(Not Expected). You may using lightdf in danger way.")
